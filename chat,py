import os
import socket
import socks
import threading
import json
import base64
import hashlib
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes

# Configuraci贸n de Tor y puerto oculto
TOR_PROXY = ("127.0.0.1", 9050)
HIDDEN_SERVICE_DIR = "/data/data/com.termux/files/home/.tor/hidden_service/"
PORT = 5000

# Generar clave de cifrado AES con una contrase帽a 煤nica por sesi贸n
SESSION_KEY = hashlib.sha256(get_random_bytes(16)).digest()


def cifrar_mensaje(mensaje):
    """Cifra un mensaje con AES-256 en modo CBC"""
    cipher = AES.new(SESSION_KEY, AES.MODE_CBC)
    iv = cipher.iv
    ciphertext = cipher.encrypt(mensaje.ljust(32).encode())  # Padding
    return base64.b64encode(iv + ciphertext).decode()


def descifrar_mensaje(mensaje_cifrado):
    """Descifra un mensaje cifrado con AES-256 en modo CBC"""
    raw = base64.b64decode(mensaje_cifrado)
    iv = raw[:16]
    ciphertext = raw[16:]
    cipher = AES.new(SESSION_KEY, AES.MODE_CBC, iv)
    return cipher.decrypt(ciphertext).strip().decode()


def iniciar_tor():
    """Inicia el servicio oculto en Tor y devuelve la direcci贸n .onion"""
    if not os.path.exists(HIDDEN_SERVICE_DIR):
        os.makedirs(HIDDEN_SERVICE_DIR)
    
    torrc_path = os.path.expanduser("~/.torrc")
    with open(torrc_path, "w") as torrc:
        torrc.write(f"HiddenServiceDir {HIDDEN_SERVICE_DIR}\n")
        torrc.write(f"HiddenServicePort {PORT} 127.0.0.1:{PORT}\n")

    os.system("pkill tor")
    os.system("tor &")
    
    # Esperar a que Tor genere el servicio
    while not os.path.exists(f"{HIDDEN_SERVICE_DIR}/hostname"):
        pass
    
    with open(f"{HIDDEN_SERVICE_DIR}/hostname", "r") as f:
        return f.read().strip()


def servidor():
    """Funci贸n que inicia el servidor y espera conexiones"""
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(("127.0.0.1", PORT))
    server.listen(1)
    print("Esperando conexi贸n...")
    
    conn, addr = server.accept()
    print("Cliente conectado.")

    while True:
        try:
            data = conn.recv(1024).decode()
            if not data:
                break
            print(f"\nCliente: {descifrar_mensaje(data)}")
            msg = input("T煤: ")
            conn.send(cifrar_mensaje(msg).encode())
        except:
            break

    conn.close()
    server.close()


def cliente(onion_address):
    """Funci贸n que act煤a como cliente y se conecta al servidor"""
    socks.set_default_proxy(socks.SOCKS5, *TOR_PROXY)
    client = socks.socksocket()
    client.connect((onion_address, PORT))
    print("Conectado al servidor.")

    def recibir():
        """Hilo para recibir mensajes"""
        while True:
            try:
                data = client.recv(1024).decode()
                if not data:
                    break
                print(f"\nServidor: {descifrar_mensaje(data)}")
            except:
                break

    threading.Thread(target=recibir, daemon=True).start()

    while True:
        msg = input("T煤: ")
        client.send(cifrar_mensaje(msg).encode())


def main():
    print(" Chat Seguro con Tor y Cifrado AES ")
    username = input("Elige un nombre de usuario 煤nico para esta sesi贸n: ")
    
    print("\n驴Quieres ser el Host o el Cliente?")
    print("[H] Host (crear chat)")
    print("[C] Cliente (conectarse)")
    opcion = input("Selecciona (H/C): ").strip().upper()

    if opcion == "H":
        print("\nIniciando Tor y servicio oculto...")
        onion_address = iniciar_tor()
        print(f"Tu direcci贸n .onion: {onion_address}")
        servidor()
    
    elif opcion == "C":
        onion_address = input("\nIngresa la direcci贸n .onion del host: ")
        cliente(onion_address)
    
    else:
        print("Opci贸n no v谩lida. Saliendo.")

if __name__ == "__main__":
    main()
